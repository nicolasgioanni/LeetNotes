Problem,Category,Time Complexity,Space Complexity,Notes
Contains Duplicate,Arrays & Hashing,O(n),O(n),"- Hashset, check if the value is in seen otherwise, add it to seen"
Valid Anagram,Arrays & Hashing,O(n + m),O(1),"Two ways to solve this:
- 1) Hashmaps to keep track of char count and then compare
- 2) ASCII values list, adding count of 1 and subtracting count of 2, at the end, the list should have counts of all 0s"
Two Sum,Arrays & Hashing,O(n),O(n),"Loop through every value
- If our target - the value we are looking at is in our hashmap of seen values, return them
- Otherwise, add it to our hashmap"
Group Anagrams,Arrays & Hashing,O(nm),O(nm),"- Loop through strings storing list of counts as the key and string as value (defaultdict(list))
- ASCII values for count
- Read-only view over the dict’s values: result.values()"
Top K Frequent Elements,Arrays & Hashing,O(n),O(n),"- Hashmap for count and dict of lists per number in input list storing count as key and number as values
- Loop to get count of each number
- Loop to store each number and its count in dict
- Return the k most frequent numbers"
Encode and Decode Strings,Arrays & Hashing,O(n),O(n + m),"Encode saving the new string as (length, unique char, string)
Decode Looping until we hit our right bound, using pointers front, middle, and end
- Front points to our first number for our string length
- Middle points to our unique char
- End points to the end of our string"
Product of Array Except Self,Arrays & Hashing,O(n),O(1) or O(n),"- Result list
- Prefix, equal first then multiply update
- Postfix, multiply first then multiply update"
Longest Consecutive Sequence,Arrays & Hashing,O(n),O(n),"- Use a set to iterate quickly
Loop over every unique number
- Check if it is a start of a sequence
- If it is, continue to check the numbers after if it is a sequence
  - Then compare it to the length of the max"
Valid Palindrome,Two Pointers,O(n),O(1),"Loop through Two pointers
- Increment/decrement whether pointer value is within ascii values to avoid non numeric values
- Compare characters at pointer values
- Update pointers"
Two Sum II Input Array Is Sorted,Two Pointers,O(n),O(1),"Loop 2 pointers
- Calculate twoSum, and update pointers based on whether greater or less than target"
Three Sum,Two Pointers,O(n^2),O(1) or O(n),"Result list and sort the input list
- Enumerate though each value in the list
- Check if the smallest value is greater than target
- After the first iteration, check if prev value is the same as current value
- Loop through pointers which are the ends after the value we enumerate
- Calculate threeSum, and update pointers based on whether equal, greater or less than target
   - When equal, update both pointers and duplicate check"
Container With Most Water,Two Pointers,O(n),O(1),"- Two pointers
- Loop through ends (pointers)
- Calculate area
- Update pointers based on which value is smaller"
Best Time to Buy and Sell Stock,Sliding Window,O(n),O(1),"Two pointers 
- Loop until our sell pointer crosses input array bounds
- If sell is greater than buy, get the max of our old and current profit
- Otherwise, this means we have a new low buy, so update pointers accordingly"
Longest Substring Without Repeating Characters,Sliding Window,O(n),O(m),"Hashmap to store char as key and its index as the value
Two pointers
- Loop through our right pointer, adding them to hashmap
- If duplicate (already in seen) & last seen duplicate char index greater than our left pointer
- Update left pointer to last seen duplicate char index + 1 (to skip it)"
Longest Repeating Character Replacement,Sliding Window,O(n),O(m),"- Dictionary to store unique letters as keys and counts as values
Two pointers, loop with right pointer, update counts and max length
- While the most frequency letter plus k is less than the length of the string
  - Update the letters count and left pointer"
Minimum Window Substring,Sliding Window,O(n + m),O(m),"- Check if are target substring is empty else continue
- Hashmaps for window and target substring
Two pointers, loop until our right pointer hits the right bound (end of input string)
  - Continously add unique char and their count to our window
  - If we have the count for all the unique letters we need save it if is it smaller than our old substring
  - Update our left pointer and decrease the count until we don't have what we need anymore"
Valid Parentheses,Stack,O(n),O(n),"Stack and Hashmap to map parentheses
- Loop through every char and check if it is open or close, add opens as needed and check stack if looking at close
- Return whether we have no more opens in our stack or if we run into the wrong close"
Binary Search,Binary Search,O(logn),O(1),"Two pointers and loop until they cross, it's okay if they're equal
- If the middle pointer is less than target, update right pointer
- Else means middle pointer is greater than target, update left pointer"
Search a 2D Matrix,Binary Search,O(lognm),O(1),"Four pointers, 2 for rows top and bottom, 2 for columns left and right
- Loop until the row pointers cross, it's okay if they're equal, get middle row
- If the first value in the middle row is less than target, update bottom row
- If the last value in the middle row is greater than target, update top row
- Else, means target must be in row and perform traditional binary search"
Koko Eating Bananas,Binary Search,O(lognm),O(1),"Two pointers, between values 1 and max rate per hour
- Loop until pointers cross, it's okay if they're equal
- Calculate total hours it takes to eat all bananas with middle rate (math.ceil(float(x) / m))
- If valid, update right pointer
- Else this means we didn't finish eating in time, update left (to eat more per hour)"
Find Minimum In Rotated Sorted Array,Binary Search,O(log n),O(1),"Two pointers, loop until they cross
- If our middle pointer is less than our right, its impossible to have a smaller number than middle
- Else means it is greater and our right subarray has the smaller value than our middle
- Last case, middle and left pointer will be the same, and if it's greater than our right, l = m + 1 = r, next iteration pointers cross"
Search In Rotated Sorted Array,Binary Search,O(log n),O(1),"Two pointers and loop until they cross, it's okay if they're equal 
- If our middle is the target, return, otherwise, two subcases
- Elif middle is greater than our left pointer (left side is sorted)
  - And If our target is greater than our middle pointer or less than our left pointer (meaning it's not in our sorted side), update left
  - Else, our target is in our sorted side and update right
- Else, meaning our right side is sorted
  - And our target is less than our middle pointer but greater than our right pointer (meaning it's not in our sorted sid), update right
  - Else, our target is in our sorted side and update left"
Reverse Linked List,Linked List,O(n),O(1),"Think of creating a new List starting with None, and redirecting every node to point to that new list 1 by 1
- Update our current nodes next to point to our previous
- Change our prevous pointer to be our current node (to continue iterating)
- Change our old current nodes next (before we changed it) to be our new current"
Merge Two Sorted Lists,Linked List,O(n + m),O(1),"1) Edge case, 2) determine head node, 3) merge loop, 4) attach rest
- Edge case if lists are None
- Compare list.val and set as head and tail, move to next node in list we took node from
- Loop while both lists have nodes, attaching smaller node to tail.next and updating tail to tail.next
- Tail.next is the node that is not None"
Linked List Cycle,Linked List,O(n),O(1),"Slow/fast pointers
- Loop until fast and its next are None constantly checking if the pointers nodes are ever equal"
Reorder List,Linked List,O(n),O(1),"Slow/fast pointers, reverse second half, merge lists:
- Slow/fast pointers to find second half, slow.next is our start second half, fast to find our end bound
- Then we need to reverse the links so we start at the end and point to the middle (second half points backwards)
- While second, save next nodes, change the nodes our currents point to, update our current nodes to temps"
Remove Nth Node From End of List,Linked List,O(n),O(1),"Slow/fast pointers, slow = head, fast = n
- If n is the size of the list (meaning fast is None) return the next node after the head
- Else we loop until the node after fast is None (because we want slow to point to the node before our nth end node)
  - Then, redirect links"
Merge K Sorted Lists,Linked List,O(n log k),O(log k),"Two pointers, Divide and conquer (recursive)
- Divide: Get the range of lists, divide until we only look at 1 which is sorted (pointers are same)
- Two pointers/conquer: Used to look at two nodes from divide and begin merging sorted lists into 1 sorted list
Key: Recursivly divide until we only have a list from both left and right halves, then slowly merge them until we have 1 resulting list"
Invert Binary Tree,Trees,O(n),O(n),"1) Edge case, 2) swap left and right nodes, 3) Recursively call on both left and right nodes (the ones we changed)"
Maximum Depth of Binary Tree (DFS),Trees,O(n),"O(h)
- O(log n), O(n)","Case 1 (no node): if root is None, that side of the tree is empty, so depth = 0.
Case 2 (node exists): return 1 (for the current node) plus the max depth of the left and right subtrees."
Same Tree (DFS),Trees,O(n),O(n),"Base case: return true if nodes are null
- Then if both not null and equal, recursively return the comparision of the left and right nodes of both trees 
- Otherwise, false"
Subtree of Another Tree (DFS),Trees,O(nm),O(n + m),"Iterate the tree using a basic stack or recursive call
- If found subtree, perform same tree check (either recursively with a seperate function or iteratively with a stack)"
Lowest Common Ancestor of a Binary Search Tree,Trees,O(h),O(1),"Case 1: Both nodes are greater than our current node, we go right
Case 2: Both nodes are less than our current node, we go left
Case 3: This means a split occured (one node is to the left and the other is to the right) or one node equals our current, LCA found"
Binary Tree Level Order Traversal,Trees,O(n),O(n),"Iterate the tree using a queue while loop
- Get the amount of nodes at that depth (length of queue)
- For every node at that depth, pop it (queue.popleft()), and add it to a temp list for that depth if not null
- If the temp list is not null (meaning nodes were present at that depth, add the temp list to the result list"
Validate Binary Search Tree (DFS),Trees,O(n),O(n),"Nested function with 3 parameters (node, left bound, right bound):
- Our first root node can be in between negative infinity and infinity
- As we iterate recursively, we must update our left and right bounds accordingly
  - Going left, update right bound to previous nodes value
  - Going right, update left bound to previous nodes value"
Kth Smallest Element In a Bst (Inorder Traversal),Trees,O(n),O(n),"Inorder Traversal: Loop while stack or node we're looking at is not null
- Go left as far as possible, pushing nodes onto a stack
- Then, begin popping the smallest value, decrementing k, and going to that nodes's right child"
Construct Binary Tree From Preorder And Inorder Traversal (DFS),Trees,O(n),O(n),"Idea: Preorder gives the root; Inorder tells us how to split into subtress
- Make a Inorder index dictonary to map the inorder values to indices for O(1) loopups
- Nested recursive function with four pointer parameters: preorder left and right, inorder left and right
  - Base case: Make sure that our left pointers for both preorder and in order do not cross eachother (okay is equal)
  - Root: Always build our root node with the preorder list index at our preorder left pointer
  - Split: We find the index of that value in the preorder list, in the inorder list (rootIndex) using our dictionary
  - Left Size (leftHalf): Compute how many nodes are in the left subtree by subtracting the inorder index (root Index) by our inorder left pointer
Recurse Left:
- preLeft: Move forward by 1 (skip over the root in preorder).
- preRight: Move our pointer to our current preLeft + the number of nodes in the leftHalf
- inLeft: Keep the same inLeft
- inRight: Move our pointer to the middle (rootIndex) - 1 to exclude our current root node (everything to the left of the root in inorder)
Recurse Right:
- preLeft: Move the pointer over by 1 + our current preLeft + the length of the leftHalf
- preRight: Keep the same preRight
- inLeft: Move our pointer to the rootIndex + 1 (everything to the right of the root in inorder).
- inRight: Keep the same inRight

Note: Only compare or use index values together if they are part of the same list"
Binary Tree Maximum Path Sum,Trees,O(n),O(h) or log(n),"Idea: Recurse through every node and return 2 things:
- The highest count path you can extend upwards (straight path)
  - We return our current nodes value + either the left path, right path, or 0 (if the left and right path are 0)
- The best count path you can find anywhere in the tree (split path)
  - We return either our current best count, or our current nodes value + left path + right path
Base case: if the node is null, return 0 and -infinity as the best count path (anything is better than a null node)"
Serialize And Deserialize Binary Tree,Trees,,,
Find Median From Data Stream,Heap / Priority Queue,,,
Combination Sum,Backtracking,,,
Word Search,Backtracking,,,
Implement Trie Prefix Tree,Tries,,,
Design Add And Search Words Data Structure,Tries,,,
Word Search II,Tries,,,
Number of Islands (BFS),Graphs,O(n): O(row * col),O(n): O(row * col),"Idea: Iterate through each coordinate (row and col) in grid/matrix and run bfs or dfs every time we see a unvisited island coordinate (not in set)
BFS or DFS: Logic works for both below but bfs pops left vs. dfs pops right
- Add the first coordinate to our visited set and to our queue (collections.deque)
- While loop as long as we have valid coordinates in our queue
- For loop to check all directions (left/right/up/down) of our current coordinates, if any of those coordinates:
  - Are within our row and col bounds (0 to the length of 0-indexed range)
  - Is an island in our grid (grid[row][col] == ""x"")
  - And is not in our visited set
- Means: we found another valid coordinate a part of this island, and we update our visited set and queue with those coordinates to reiterate
- Otherwise: we do nothing until the queue is empty"
Clone Graph (DFS),Graphs,O(V * E),O(V),"Idea: Recursively clone each node using the old node and returning the cloned node (whether it's already cloned or not):
1) If the old node is already in the map, return its clone (because our recursive call takes in the old node)
2) Otherwise, create the clone and update our hashmap (old : new) that the node has been copied.
3) For each neighbor of the old node, get the neighbor’s clone by recursion and append it to the current clone’s neighbors
Question: Why the hashmap? 
Answer: It is both the visited check and the way to fetch the exact clone needed to wire edges (when we are updating neighbors of already cloned nodes)"
Pacific Atlantic Water Flow (DFS),Graphs,O(n): O(row * col),O(n): O(row * col),"Idea: Iterate through top/bottom, left/right sides and recursively dfs go inward storing valid coordinates in sets (coordinates that are in a path to ocean)
1) Top/Bottom: Iterate through cols and recursive dfs on every coordinate on the top and bottom row (0, rows -1)
2) Left/Right: Iterate through rows and recursive dfs on every coordinate on the left and right cols (0, cols - 1)
3) DFS: If the row/col is within bounds, the coordinate has a equal or greater height than our old, and is not already marked reachable:
  - Mark it as reachable for that respective ocean
  - Recursively check all 4 directions
4) Result: Iterate over one ocean’s reachable set and add any cell that also appears in the other ocean’s set to the result"
Course Schedule (DFS),Graphs,O(V * E),O(V * E),"Idea: Map course to its prerequisites, and run dfs on each prerequiste keeping track of the path
1) Data structures: adjacency map (course to prerequisites); path set (path in our DFS process)
2) Iteration: Run DFS on every course; If any returns false, return false.
3) DFS:
  - Base case 1) If a course is already on our path (cycle), return false
  - Base case 2) If a course has no prerequsites (completed), return true
  - Otherwise: Add the course to our path and DFS on all prerequisites and:
    - If any of the DFS on prerequistes return false, return false
    - Else memoize and remove all the prerequisites for that course"
Graph Valid Tree (DFS),Graphs,O(V * E),O(V * E),"Base Check: If the number of edges isn’t equal to the number of nodes minus one, the graph can’t be a valid tree
Reason: After the first node, each added node needs exactly one new edge to connect them to be a valid tree
1) Data Structures:
  - Adjacency List: Map nodes to neighbors and back
  - Visited Set: Store every node visited for iteration/recursion using dfs/bfs
2) Run DFS on any node passing a current node and previous node as parameters:
  - Base case: Check if node is in visited
  - For every neighbor the current node has, i
    - If the neighbor is the previous node, skip it
    - If the DFS call on the neighbor nodes is false, return false (caught a cycle)
  - If the for loop preformed without failing, return True
3) Return the boolean result of both (and): 
  - The DFS call
  - Whether or not the number of visited nodes equals the total number of nodes (n)"
Number of Connected Components In An Undirected Graph,Graphs,O(V * E),O(V * E),"1) Data Structures:
  - Adjacency List: Map nodes to neighbors and back
  - Visited Set: Store every node visited for iteration/recursion dfs/bfs
  - Components Count: Store amount of components detected
2) Linear Iteration:
  - For each node in the graph
    - If we have not visitied yet, mark it as visited, run DFS, and increment our components counter
3) DFS:
  - For every neighbor the passed node has
    - If the neighbor is not in visited, mark it as visited and run DFS"
Alien Dictionary,Advanced Graphs,,,
Climbing Stairs,1-D Dynamic Programming,,,
House Robber,1-D Dynamic Programming,,,
House Robber II,1-D Dynamic Programming,,,
Longest Palindromic Substring,1-D Dynamic Programming,,,
Palindromic Substrings,1-D Dynamic Programming,,,
Decode Ways,1-D Dynamic Programming,,,
Coin Change,1-D Dynamic Programming,,,
Maximum Product Subarray,1-D Dynamic Programming,,,
Word Break,1-D Dynamic Programming,,,
Longest Increasing Subsequence,1-D Dynamic Programming,,,
Unique Paths,2-D Dynamic Programming,,,
Longest Common Subsequence,2-D Dynamic Programming,,,
Maximum Subarray,Greedy,,,
Jump Game,Greedy,,,
Insert Interval,Intervals,,,
Merge Intervals,Intervals,,,
Non Overlapping Intervals,Intervals,,,
Meeting Rooms,Intervals,,,
Meeting Rooms II,Intervals,,,
Rotate Image,Math & Geometry,,,
Spiral Matrix,Math & Geometry,,,
Set Matrix Zeroes,Math & Geometry,,,
Number of 1 Bits,Bit Manipulation,,,
Counting Bits,Bit Manipulation,,,
Reverse Bits,Bit Manipulation,,,
Missing Number,Bit Manipulation,,,
Sum of Two Integers,Bit Manipulation,,,